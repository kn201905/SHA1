

;--------------------------------------------
; macro implements 80 rounds of SHA-1, for one 64-byte block or multiple blocks with s/w pipelining
;
; macro param: =0 - process single 64-byte block
;              =1 - multiple blocks

%macro SHA1_PIPELINED_MAIN_BODY 1

	mov A, [HASH_PTR   ]
	mov B, [HASH_PTR+ 4]
	mov C, [HASH_PTR+ 8]
	mov D, [HASH_PTR+12]
	mov E, [HASH_PTR+16]

	%assign i 0
	%rep    W_PRECALC_AHEAD
		W_PRECALC i
		%assign i i+1
	%endrep

	%xdefine F F1

	%if (%1 == 1)                         ;; code loops through more than one block
%%_loop:
		cmp BUFFER_PTR, K_BASE          ;; we use K_BASE value as a signal of a last block,
		jne %%_begin                    ;; it is set below by: cmovae BUFFER_PTR, K_BASE
		jmp %%_end

		align 32
%%_begin:
	%endif

	RR A,B,C,D,E,0
	RR D,E,A,B,C,2
	RR B,C,D,E,A,4
	RR E,A,B,C,D,6
	RR C,D,E,A,B,8

	RR A,B,C,D,E,10
	RR D,E,A,B,C,12
	RR B,C,D,E,A,14
	RR E,A,B,C,D,16
	RR C,D,E,A,B,18

	%xdefine F F2

	RR A,B,C,D,E,20
	RR D,E,A,B,C,22
	RR B,C,D,E,A,24
	RR E,A,B,C,D,26
	RR C,D,E,A,B,28

	RR A,B,C,D,E,30
	RR D,E,A,B,C,32
	RR B,C,D,E,A,34
	RR E,A,B,C,D,36
	RR C,D,E,A,B,38

	%xdefine F F3

	RR A,B,C,D,E,40
	RR D,E,A,B,C,42
	RR B,C,D,E,A,44
	RR E,A,B,C,D,46
	RR C,D,E,A,B,48

	RR A,B,C,D,E,50
	RR D,E,A,B,C,52
	RR B,C,D,E,A,54
	RR E,A,B,C,D,56
	RR C,D,E,A,B,58

	%xdefine F F4

	%if (%1 == 1)                         ;; if code loops through more than one block

		add   BUFFER_PTR, 64            ;; move to next 64-byte block
		cmp   BUFFER_PTR, BUFFER_END    ;; check if current block is the last one
		cmovae BUFFER_PTR, K_BASE       ;; smart way to signal the last iteration

	%else

		%xdefine W_NO_TAIL_PRECALC 1    ;; no software pipelining for single block interface

	%endif

	RR A,B,C,D,E,60
	RR D,E,A,B,C,62
	RR B,C,D,E,A,64
	RR E,A,B,C,D,66
	RR C,D,E,A,B,68

	RR A,B,C,D,E,70
	RR D,E,A,B,C,72
	RR B,C,D,E,A,74
	RR E,A,B,C,D,76
	RR C,D,E,A,B,78

	UPDATE_HASH [HASH_PTR   ],A
	UPDATE_HASH [HASH_PTR+ 4],B
	UPDATE_HASH [HASH_PTR+ 8],C
	UPDATE_HASH [HASH_PTR+12],D
	UPDATE_HASH [HASH_PTR+16],E

	%if (%1 == 1)

		jmp %%_loop

		align 32  
%%_end:
	%endif

	%xdefine W_NO_TAIL_PRECALC 0
	%xdefine F %error
%endmacro


%macro F1 3
	mov T1,%2  ; T1 = eax
	xor T1,%3
	and T1,%1
	xor T1,%3
%endmacro

%macro F2 3
	mov T1,%3
	xor T1,%2
	xor T1,%1
%endmacro

%macro F3 3
	mov T1,%2
	mov T2,%1
	or  T1,%1
	and T2,%2
	and T1,%3
	or  T1,T2
%endmacro

%define F4 F2

%macro UPDATE_HASH 2
	add %2, %1
	mov %1, %2
%endmacro



%macro W_PRECALC_RESET 0
	%xdefine    W             W0
	%xdefine    W_minus_04    W4
	%xdefine    W_minus_08    W8
	%xdefine    W_minus_12    W12
	%xdefine    W_minus_16    W16
	%xdefine    W_minus_20    W20
	%xdefine    W_minus_24    W24
	%xdefine    W_minus_28    W28
	%xdefine    W_minus_32    W
%endmacro


%macro W_PRECALC_ROTATE 0
	%xdefine    W_minus_32    W_minus_28
	%xdefine    W_minus_28    W_minus_24
	%xdefine    W_minus_24    W_minus_20
	%xdefine    W_minus_20    W_minus_16
	%xdefine    W_minus_16    W_minus_12
	%xdefine    W_minus_12    W_minus_08
	%xdefine    W_minus_08    W_minus_04
	%xdefine    W_minus_04    W
	%xdefine    W             W_minus_32
%endmacro

%xdefine W_PRECALC_AHEAD   16
%xdefine W_NO_TAIL_PRECALC 0

%xdefine xmm_mov            movdqa


%macro W_PRECALC_00_15 0
	;; message scheduling pre-compute for rounds 0-15

	%if ((i &amp; 3) == 0)       ;; blended SSE and ALU instruction scheduling, 1 vector iteration per 4 rounds
		movdqu W_TMP, [BUFFER_PTR + (i * 4)]

	%elif ((i &amp; 3) == 1)
		pshufb W_TMP, XMM_SHUFB_BSWAP
		movdqa W, W_TMP

	%elif ((i &amp; 3) == 2)
		paddd  W_TMP, [K_BASE]

	%elif ((i &amp; 3) == 3)
		movdqa  [WK(i&amp;~3)], W_TMP
		W_PRECALC_ROTATE
	%endif
%endmacro


%macro W_PRECALC_16_31 0
	;; message scheduling pre-compute for rounds 16-31
	;; calculating last 32 w[i] values in 8 XMM registers
	;; pre-calculate K+w[i] values and store to mem, for later load by ALU add instruction
	;;
	;; "brute force" vectorization for rounds 16-31 only due to w[i]-&gt;w[i-3] dependency

	%if ((i &amp; 3) == 0)    ;; blended SSE and ALU instruction scheduling, 1 vector iteration per 4 rounds
		movdqa  W, W_minus_12
		palignr W, W_minus_16, 8       ;; w[i-14]
		movdqa  W_TMP, W_minus_04
		psrldq  W_TMP, 4               ;; w[i-3]
		pxor    W, W_minus_08

	%elif ((i &amp; 3) == 1)
		pxor    W_TMP, W_minus_16
		pxor    W, W_TMP
		movdqa  W_TMP2, W
		movdqa  W_TMP, W
		pslldq  W_TMP2, 12

	%elif ((i &amp; 3) == 2)
		psrld   W, 31
		pslld   W_TMP, 1
		por     W_TMP, W
		movdqa  W, W_TMP2
		psrld   W_TMP2, 30
		pslld   W, 2

	%elif ((i &amp; 3) == 3)
		pxor    W_TMP, W
		pxor    W_TMP, W_TMP2
		movdqa  W, W_TMP
		paddd   W_TMP, [K_BASE + K_XMM]
		movdqa  [WK(i&amp;~3)],W_TMP

		W_PRECALC_ROTATE

	%endif
%endmacro


%macro W_PRECALC_32_79 0
	;; in SHA-1 specification: w[i] = (w[i-3] ^ w[i-8]  ^ w[i-14] ^ w[i-16]) rol 1
	;; instead we do equal:    w[i] = (w[i-6] ^ w[i-16] ^ w[i-28] ^ w[i-32]) rol 2
	;; allows more efficient vectorization since w[i]=>w[i-3] dependency is broken

	%if ((i &amp; 3) == 0)    ;; blended SSE and ALU instruction scheduling, 1 vector iteration per 4 rounds
		movdqa  W_TMP, W_minus_04
		pxor    W, W_minus_28         ;; W is W_minus_32 before xor
		palignr W_TMP, W_minus_08, 8

	%elif ((i &amp; 3) == 1)
		pxor    W, W_minus_16
		pxor    W, W_TMP
		movdqa  W_TMP, W

	%elif ((i &amp; 3) == 2)
		psrld   W, 30
		pslld   W_TMP, 2
		por     W_TMP, W

	%elif ((i &amp; 3) == 3)
		movdqa  W, W_TMP
		paddd   W_TMP, [K_BASE + K_XMM]
		movdqa  [WK(i&amp;~3)],W_TMP

		W_PRECALC_ROTATE
	%endif
%endmacro


;;; %macro RR 6      ;; RR does two rounds of SHA-1 back to back with W pre-calculation
;;; %endmacro


;;----------------------
section .data align=128

	%xdefine K1 0x5a827999
	%xdefine K2 0x6ed9eba1
	%xdefine K3 0x8f1bbcdc
	%xdefine K4 0xca62c1d6

	align 128

K_XMM_AR:
	DD K1, K1, K1, K1
	DD K2, K2, K2, K2
	DD K3, K3, K3, K3
	DD K4, K4, K4, K4

	align 16

bswap_shufb_ctl:
	DD 00010203h
	DD 04050607h
	DD 08090a0bh
	DD 0c0d0e0fh


;;----------------------

section .text align=4096
	SHA1_VECTOR_ASM     sha1_update_intel_ssse3_, multiblock

	align 32


sha1_update_intel:    ;; C++ から呼び出される最初のアドレス
	jmp     sha1_update_intel_ssse3_



